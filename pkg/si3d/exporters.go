package si3d

import (
	"bufio"
	"fmt"
	"image/color"
	"os"
)

// SaveDXF writes the model's base geometry to a file in DXF format.
// It correctly retrieves face data whether the model uses a BSP tree or a simple face list.
// Note: This function replaces the original stub, which had a signature and logic
// unsuited for file-saving operations.
func (o *Model) SaveDXF(fileName string) error {
	file, err := os.Create(fileName)
	if err != nil {
		return fmt.Errorf("could not create DXF file %s: %w", fileName, err)
	}
	defer file.Close()

	writer := bufio.NewWriter(file)

	// writePair is a helper function to write a DXF group code and its value.
	writePair := func(code int, value interface{}) {
		// This will handle potential errors during write, though we'll check the final flush.
		_, _ = fmt.Fprintf(writer, "%d\n%v\n", code, value)
	}

	// --- 1. Collect all face indices from the model ---
	var allFaceIndices [][]int

	if o.canPaintWithoutBSP {
		// If no BSP tree is used, the indices are stored in a simple list.
		allFaceIndices = o.faceIndices
	} else if o.root != nil {
		// If a BSP tree is used, we must traverse it to collect the face indices from each node.
		// This assumes BspNode has fields: Left *BspNode, Right *BspNode, and pointIndices []int.
		allFaceIndices = make([][]int, 0)
		var collectIndices func(node *BspNode)
		collectIndices = func(node *BspNode) {
			if node == nil {
				return
			}
			// Each node in the BSP tree represents a polygon.
			allFaceIndices = append(allFaceIndices, node.facePointIndices)
			// Recursively traverse the child nodes.
			collectIndices(node.Left)
			collectIndices(node.Right)
		}
		collectIndices(o.root)
	}

	// --- 2. Write the standard DXF file structure ---

	// Header Section (minimal)
	writePair(0, "SECTION")
	writePair(2, "HEADER")
	writePair(0, "ENDSEC")

	// Entities Section
	writePair(0, "SECTION")
	writePair(2, "ENTITIES")

	// --- 3. Write each face from the collected indices as a 3DFACE entity ---
	for _, faceIdxs := range allFaceIndices {
		if len(faceIdxs) < 3 {
			continue // A face must have at least 3 vertices.
		}

		writePair(0, "3DFACE")
		writePair(8, "0") // Layer name

		// A 3DFACE entity requires 4 vertices. For triangles, the 4th vertex repeats the 3rd.
		p1 := o.faceMesh.Points[faceIdxs[0]]
		p2 := o.faceMesh.Points[faceIdxs[1]]
		p3 := o.faceMesh.Points[faceIdxs[2]]

		var p4 Vector3
		if len(faceIdxs) > 3 {
			p4 = o.faceMesh.Points[faceIdxs[3]]
		} else {
			p4 = p3 // For a triangle, repeat the third vertex.
		}

		// Write vertex coordinates with their corresponding group codes.
		writePair(10, p1.X) // Vertex 1: X
		writePair(20, p1.Y) // Vertex 1: Y
		writePair(30, p1.Z) // Vertex 1: Z

		writePair(11, p2.X) // Vertex 2: X
		writePair(21, p2.Y) // Vertex 2: Y
		writePair(31, p2.Z) // Vertex 2: Z

		writePair(12, p3.X) // Vertex 3: X
		writePair(22, p3.Y) // Vertex 3: Y
		writePair(32, p3.Z) // Vertex 3: Z

		writePair(13, p4.X) // Vertex 4: X
		writePair(23, p4.Y) // Vertex 4: Y
		writePair(33, p4.Z) // Vertex 4: Z
	}

	// End of Entities Section
	writePair(0, "ENDSEC")

	// End of File marker
	writePair(0, "EOF")

	// Flush the writer to ensure all data is written to the file and return any error.
	return writer.Flush()
}

func (o *Model) SavePLYWithFaceColors(fileName string) error {
	file, err := os.Create(fileName)
	if err != nil {
		return fmt.Errorf("could not create PLY file %s: %w", fileName, err)
	}
	defer file.Close()

	writer := bufio.NewWriter(file)

	// Helper struct to associate face indices with their color.
	type coloredFace struct {
		indices []int
		color   color.RGBA
	}

	// Collect all face indices and their corresponding colors
	allFaces := make([]coloredFace, 0)
	if o.canPaintWithoutBSP {
		for i, faceIdxs := range o.faceIndices {
			if i < len(o.faces.faces) {
				faceColor := o.faces.faces[i].Col
				allFaces = append(allFaces, coloredFace{indices: faceIdxs, color: faceColor})
			}
		}
	} else if o.root != nil {
		var collectFromBSP func(node *BspNode)
		collectFromBSP = func(node *BspNode) {
			if node == nil {
				return
			}
			nodeColor := color.RGBA{R: node.colRed, G: node.colGreen, B: node.colBlue, A: node.colAlpha}
			allFaces = append(allFaces, coloredFace{indices: node.facePointIndices, color: nodeColor})
			collectFromBSP(node.Left)
			collectFromBSP(node.Right)
		}
		collectFromBSP(o.root)
	}

	numVertices := len(o.faceMesh.Points)

	// Write the modified PLY file header
	// Note that the color properties are now part of the "face" element.
	_, _ = fmt.Fprintln(writer, "ply")
	_, _ = fmt.Fprintln(writer, "format ascii 1.0")
	_, _ = fmt.Fprintf(writer, "comment Generated by si3d with face colors\n")
	_, _ = fmt.Fprintf(writer, "element vertex %d\n", numVertices)
	_, _ = fmt.Fprintln(writer, "property float x")
	_, _ = fmt.Fprintln(writer, "property float y")
	_, _ = fmt.Fprintln(writer, "property float z")
	_, _ = fmt.Fprintf(writer, "element face %d\n", len(allFaces))
	_, _ = fmt.Fprintln(writer, "property list uchar int vertex_indices")
	_, _ = fmt.Fprintln(writer, "property uchar red")   // <-- Moved to face element
	_, _ = fmt.Fprintln(writer, "property uchar green") // <-- Moved to face element
	_, _ = fmt.Fprintln(writer, "property uchar blue")  // <-- Moved to face element
	_, _ = fmt.Fprintln(writer, "end_header")

	// --- 3. Write vertex data (coordinates ONLY) ---
	for _, vertex := range o.faceMesh.Points {
		_, _ = fmt.Fprintf(writer, "%f %f %f\n", vertex.X, vertex.Y, vertex.Z)
	}

	// --- 4. Write face data (indices AND color) ---
	for _, face := range allFaces {
		numFaceVerts := len(face.indices)
		if numFaceVerts < 3 {
			continue
		}

		// Start line with number of vertices for this face.
		_, _ = fmt.Fprintf(writer, "%d", numFaceVerts)

		// Append the vertex indices.
		for _, vIndex := range face.indices {
			_, _ = fmt.Fprintf(writer, " %d", vIndex)
		}

		// Append the face color at the end of the line.
		col := face.color
		_, _ = fmt.Fprintf(writer, " %d %d %d\n", col.R, col.G, col.B)
	}

	return writer.Flush()
}
